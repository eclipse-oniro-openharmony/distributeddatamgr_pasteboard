/*
 * Copyright (c) 2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@!namespace("@ohos.pasteboard", "pasteboard")

@!sts_inject("""
static { loadLibrary("pasteboard_taihe_native.z") }
""")

@!sts_inject_into_module("import { BusinessError, RecordData } from '@ohos.base';")

@!sts_inject_into_module("import Want from '@ohos.app.ability.Want';")

@!sts_inject_into_module("import image from '@ohos.multimedia.image';")

@!sts_inject_into_module("import unifiedDataChannel from '@ohos.data.unifiedDataChannel';")

@!sts_inject("const MIMETYPE_TEXT_HTML: String = 'text/html'")

@!sts_inject("const MIMETYPE_TEXT_PLAIN: String = 'text/plain'")

@!sts_inject("const MIMETYPE_TEXT_URI: String = 'text/uri'")

@!sts_inject("const MIMETYPE_TEXT_WANT: String = 'text/want'")

@!sts_inject("const MIMETYPE_PIXELMAP: String = 'pixelMap'")

@!sts_inject("const MAX_RECORD_NUM: int = 512")

enum ShareOption: i32 {
    INAPP = 0,
    LOCALDEVICE = 1
}

enum Pattern: i32 {
    URL = 0,
    NUMBER = 1,
    EMAIL_ADDRESS = 2,
    COUNT
}

union ValueType {
    string: String;
    arrayBuffer: @arraybuffer Array<u8>;
    pixelMapOrWant: @sts_type("(image.PixelMap | Want)") Opaque;
}

struct PasteDataProperty {
    additions: @record Map<String, @sts_type("RecordData") Opaque>;
    @readonly mimeTypes: Array<String>;
    localOnly: bool;
    shareOption: ShareOption;
    @readonly timestamp: i64;
    tag: String;
}

interface PasteDataRecord {
    @get("htmlText")
    GetHtmlText(): String;

    @get("want")
    GetWant(): @sts_type("Want") Opaque;

    @get("mimeType")
    GetMimeType(): String;

    @get("plainText")
    GetPlainText(): String;

    @get("uri")
    GetUri(): String;

    @get("pixelMap")
    GetPixelMap(): @sts_type("image.PixelMap") Opaque;

    @get("data")
    GetData(): @record Map<String, @arraybuffer Array<u8>>;

    @gen_promise("getData")
    GetRecordValueByType(type: String): ValueType;

    ToPlainText(): String;
    AddEntry(type: String, value: ValueType): void;
    GetValidTypes(types: Array<String>): Array<String>;

    GetRecordImpl(): i64;
}
function MakePasteDataRecord(): PasteDataRecord;

interface PasteData {
    @overload("addRecord")
    AddRecord(record: PasteDataRecord);
    @overload("addRecord")
    CreateAndAddRecord(mimeType: String, value: ValueType);

    GetMimeTypes(): Array<String>;
    GetPrimaryHtml(): String;
    GetPrimaryWant(): @sts_type("Want") Opaque;
    GetPrimaryMimeType(): String;
    GetPrimaryText(): String;
    GetPrimaryUri(): String;
    GetPrimaryPixelMap(): @sts_type("image.PixelMap") Opaque;
    GetProperty(): PasteDataProperty;
    SetProperty(property: PasteDataProperty): void;
    GetRecord(index: i32): PasteDataRecord;
    GetRecordCount(): i32;
    GetTag(): String;

    HasType(mimeType: String): bool;
    RemoveRecord(index: i32): void;
    ReplaceRecord(index: i32, record: PasteDataRecord): void;
    PasteStart(): void;
    PasteComplete(): void;

    GetPasteDataImpl(): i64;
}
function CreatePasteData(): PasteData;

enum FileConflictOptions : i32 {
    OVERWRITE = 0,
    SKIP = 1,
    RENAME
}

enum ProgressIndicator : i32 {
    NONE = 0,
    DEFAULT = 1
}

struct ProgressInfo {
    progress: i32;
}

struct GetDataParams {
    destUri: Optional<String>;
    fileConflictOptions: Optional<FileConflictOptions>;
    progressIndicator: ProgressIndicator;
    progressListener: Optional<(progress: ProgressInfo) => void>;
    progressSignal: Optional<ProgressSignal>;
}

interface SystemPasteboard {

    @!sts_inject_into_interface("""
        on(type: string, callback: () => void): void;
        off(type: string, callback?: () => void): void;
    """)
    @!sts_inject_into_class("""
        on(type: string, cb: object) {
            switch(type) {
                case "update": return this.onUpdate(cb as () => void, cb);
                default: throw new BusinessError(401, new Error("Parameter error. The value of type must be update."));
            }
        }
        off(type: string, cb?: object) {
            switch(type) {
                case "update": return this.offUpdate(cb);
                default: throw new BusinessError(401, new Error("Parameter error. The value of type must be update."));
            }
        }
    """)
    OnUpdate(callback: () => void, cb: Opaque);
    OffUpdate(cb: Optional<Opaque>);

    @gen_async("clearData")
    @gen_promise("clearData")
    ClearDataImpl(): void;

    @gen_async("getData")
    @gen_promise("getData")
    GetDataImpl(): PasteData;

    @gen_async("hasData")
    @gen_promise("hasData")
    HasDataImpl(): bool;

    @gen_async("setData")
    @gen_promise("setData")
    SetDataImpl(data: PasteData): void;

    @gen_promise("getMimeTypes")
    GetMimeTypesSync(): Array<String>;

    GetDataSource(): String;
    HasDataType(mimeType: String): bool;
    ClearDataSync(): void;
    GetDataSync(): PasteData;
    HasDataSync(): bool;

    IsRemoteData(): bool;
    SetDataSync(data: PasteData): void;

    @gen_promise("getUnifiedData")
    GetUnifiedDataImpl(): @sts_type("unifiedDataChannel.UnifiedData") Opaque;
    GetUnifiedDataSync(): @sts_type("unifiedDataChannel.UnifiedData") Opaque;

    @gen_promise("setUnifiedData")
    SetUnifiedDataImpl(data: @sts_type("unifiedDataChannel.UnifiedData") Opaque): void;
    SetUnifiedDataSync(data: @sts_type("unifiedDataChannel.UnifiedData") Opaque): void;

    SetAppShareOptions(shareOptions: ShareOption): void;
    RemoveAppShareOptions(): void;

    @gen_promise("detectPatterns")
    DetectPatternsImpl(patterns: Array<Pattern>): Array<Pattern>;

    GetChangeCount(): i64;

    @gen_promise("getDataWithProgress")
    GetDataWithProgressImpl(params: GetDataParams): PasteData;
}
function CreateSystemPasteboard(): SystemPasteboard;

@overload("createData")
function CreateDataByValue(mimeType: String, value: ValueType): PasteData;

@overload("createData")
function CreateDataByRecord(data: @record Map<String, ValueType>): PasteData;

function GetSystemPasteboard(): SystemPasteboard;

function CreateRecord(mimeType: String, value: ValueType): PasteDataRecord;

@class
interface ProgressSignal {
    Cancel(): void;
}

@rename @constructor("ProgressSignal")
function getProgressSignal(): ProgressSignal;

@!sts_inject("""
export function pasteDataTransferStatic(input: Any): object {
    return pasteDataTransferStaticImpl(ESValue.wrap(input));
}
export function pasteDataTransferDynamic(input: object): Any {
    return pasteDataTransferDynamicImpl(input as PasteData);
}
export function pasteDataRecordTransferStatic(input: Any): object {
    return pasteDataRecordTransferStaticImpl(ESValue.wrap(input));
}
export function pasteDataRecordTransferDynamic(input: object): Any {
    return pasteDataRecordTransferDynamicImpl(input as PasteDataRecord);
}
""")

function PasteDataTransferStaticImpl(input: @sts_type("ESValue") Opaque): PasteData;

function PasteDataTransferDynamicImpl(input: PasteData): @sts_type("Any") Opaque;

function PasteDataRecordTransferStaticImpl(input: @sts_type("ESValue") Opaque): PasteDataRecord;

function PasteDataRecordTransferDynamicImpl(input: PasteDataRecord): @sts_type("Any") Opaque;